<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java类加载 | Mine &amp; Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="思维导图 类加载简述Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称作虚拟机的类加载机制。 💡 类加载日志显示:     java8 ：-verbose:class -XX:+TraceClassLoading -XX:+TraceClassUnloading     java9之后：-">
<meta property="og:type" content="article">
<meta property="og:title" content="Java类加载">
<meta property="og:url" content="http://example.com/2022/06/06/yuque/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/index.html">
<meta property="og:site_name" content="Mine &amp; Blog">
<meta property="og:description" content="思维导图 类加载简述Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称作虚拟机的类加载机制。 💡 类加载日志显示:     java8 ：-verbose:class -XX:+TraceClassLoading -XX:+TraceClassUnloading     java9之后：-">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/28603640/1655709490731-aa744268-32c1-4c42-85d8-72a3c9bb2070.jpeg">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655020799680-25c805ed-7098-4240-a45b-c14535727f37.png#clientId=u362b54ee-beaa-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=aPjks&margin=%5Bobject%20Object%5D&name=image.png&originHeight=458&originWidth=1080&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=269570&status=done&style=none&taskId=ucc45a26d-4804-4687-881f-e8f01c77765&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655052017249-0d444c59-261c-4941-938f-c5998d287e62.png#clientId=u362b54ee-beaa-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6205efc4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=575&originWidth=896&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=230941&status=done&style=none&taskId=u3f144666-a062-41a0-9ec0-27310bcf95b&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655697762109-a3c2a687-cbad-45a5-a817-500410d4f032.png#clientId=u762f29bb-63f0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=198&id=ucce46fe8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=198&originWidth=717&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=130243&status=done&style=none&taskId=u28ce919c-ba6f-43e9-a088-cb4998cf497&title=&width=717">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655660461531-8d36e672-3d46-429a-80d6-5bd38f6e2ec7.png#clientId=u6fc6605e-52e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u962aedcd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=441&originWidth=728&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=44200&status=done&style=none&taskId=u60580985-df5e-4a3f-bcdd-e570e068f38&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655727911712-563b1b2e-fec6-4613-8183-0726d364bf81.png#clientId=ub570b698-5357-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=535&id=u473e7f78&margin=%5Bobject%20Object%5D&name=image.png&originHeight=535&originWidth=872&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=74738&status=done&style=none&taskId=ub95ffd72-51c1-49ed-9bcc-9c508531087&title=&width=872">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655697820047-c699a92c-86f4-4e52-bf0e-122fbd46321e.png#clientId=u762f29bb-63f0-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u51c7fcce&margin=%5Bobject%20Object%5D&name=image.png&originHeight=133&originWidth=693&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=90623&status=done&style=none&taskId=u8c5f6b7e-bd98-49ca-9762-ae386a79de5&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655050522139-6f5d0a82-cbdb-4228-858d-1da356589d89.png#clientId=u362b54ee-beaa-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua57ef7a0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=338&originWidth=1116&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=72933&status=done&style=none&taskId=ud3dd855a-bbe1-4ce1-a89e-d4f5c4147f0&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655705401386-c50d50aa-7902-45fe-a41f-730808ad2df8.png#clientId=u7a32fd17-810c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=111&id=u5b76e185&margin=%5Bobject%20Object%5D&name=image.png&originHeight=111&originWidth=675&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=108370&status=done&style=none&taskId=u978d45f0-6fb5-4672-ad05-70755df63e1&title=&width=675">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655705386619-0011e56d-5159-4fb1-bfc8-70c7be3244eb.png#clientId=u7a32fd17-810c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=467&id=u55bb0ad3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=467&originWidth=663&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=357428&status=done&style=none&taskId=u5ca470c5-5b53-4beb-934f-c8ffde9310d&title=&width=663">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655057069184-da6095ba-9623-4b23-89e2-e7c637512113.png#clientId=u362b54ee-beaa-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9a565e09&margin=%5Bobject%20Object%5D&name=image.png&originHeight=271&originWidth=676&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=41413&status=done&style=none&taskId=u5384eac8-5482-4a23-86cb-8a73d41fe27&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655057514597-ee3de33a-6706-4d16-ab6d-018a1a669235.png#clientId=u362b54ee-beaa-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=544&id=ubdd1ec86&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1087&originWidth=1336&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=345267&status=done&style=none&taskId=u6e15724a-8545-4337-9f08-e6fb91450f2&title=&width=668">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655709127835-a02e73c4-9797-42b1-89ab-573f77080ecd.png#clientId=u299c494b-3abe-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=599&id=u2884fe05&margin=%5Bobject%20Object%5D&name=image.png&originHeight=599&originWidth=741&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=61084&status=done&style=none&taskId=u3cc4ab7e-09ef-48a2-aaf9-8bb40ba8df3&title=&width=741">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655711928599-1e3dd2d6-447a-446c-b7aa-04ae595efdd2.png#clientId=ue833c6b2-19ed-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=560&id=fqyky&margin=%5Bobject%20Object%5D&name=image.png&originHeight=560&originWidth=602&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=124033&status=done&style=none&taskId=u4523417f-4477-4238-af4a-d39ba84cffa&title=&width=602">
<meta property="article:published_time" content="2022-06-05T16:26:27.000Z">
<meta property="article:modified_time" content="2022-08-24T19:15:47.693Z">
<meta property="article:author" content="叶不空">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/28603640/1655709490731-aa744268-32c1-4c42-85d8-72a3c9bb2070.jpeg">
  
    <link rel="alternate" href="/atom.xml" title="Mine &amp; Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mine &amp; Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-yuque/Java类加载" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/06/06/yuque/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/" class="article-date">
  <time datetime="2022-06-05T16:26:27.000Z" itemprop="datePublished">2022-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java类加载
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/28603640/1655709490731-aa744268-32c1-4c42-85d8-72a3c9bb2070.jpeg"></p>
<h2 id="类加载简述"><a href="#类加载简述" class="headerlink" title="类加载简述"></a>类加载简述</h2><p>Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称作虚拟机的类加载机制。</p>
<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">💡 类加载日志显示:
    java8 ：-verbose:class -XX:+TraceClassLoading -XX:+TraceClassUnloading
    java9之后：-verbose:class -Xlog:class+load -Xlog:class+unload
   类直方图:
   -XX:+PrintClassHistogramAfterFullGC
  -XX:+PrintClassHistogramBeforeFullGC
   -XX:+PrintClassHistogram 按下 Ctrl+Break (和Ctrl+c不同)后打印类直方图，结果等同于jmap -histo</div>

<h2 id="类加载，卸载时机"><a href="#类加载，卸载时机" class="headerlink" title="类加载，卸载时机"></a>类加载，卸载时机</h2><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称 为连接（Linking）。<br>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定,它是一个可选的操作：它在某些情况下可以在初始化阶段之后再开始， 这是为了支持 Java 语言的运行时绑定特性（也称为动态绑定或晚期绑定）。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655020799680-25c805ed-7098-4240-a45b-c14535727f37.png#clientId=u362b54ee-beaa-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=aPjks&margin=%5Bobject%20Object%5D&name=image.png&originHeight=458&originWidth=1080&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=269570&status=done&style=none&taskId=ucc45a26d-4804-4687-881f-e8f01c77765&title=" alt="image.png"></p>
<p>关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java 虚拟机规范》中并没有进行 强制约束，这点可以交给虚拟机的具体实现来自由把握。但是《<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5">Java 虚拟机规范 5.5</a>》约定，在发生下列行为时，类或接口将会被初始化(可以称为类的主动引用)：<a target="_blank" rel="noopener" href="https://gitee.com/yebukong/scratchpad/blob/main/scratchpad-simple/src/test/java/pers/mine/scratchpad/base/classload/ClassLoadRefTypeTest.java">code</a></p>
<ol>
<li>在执行下列需要引用类或接口的 Java 虚拟机指令时：new，getstatic，putstatic 或 invokestatic。这些指令通过字段或方法引用来直接或间接地引用其它类。能够生成这四条指令的典型 Java 代码场景有：</li>
</ol>
<ul>
<li>使用 new 关键字实例化对象的时候。</li>
<li>读取或设置一个类型的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候。</li>
<li>调用一个类型的静态方法的时候。</li>
</ul>
<ol>
<li>在调用 java.lang.invoke.MethodHandle 实例时，它的执行结果为通过 Java 虚拟机解析出类型是 2（REF_getStatic）、4（REF_putStatic）、6（REF_invokeStatic）,或者 8 (REF_newInvokeSpecial)的方法句柄。这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>在调用 JDK 核心类库中的反射方法时，例如，Class 类或 java.lang.reflect 包，如果类型没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当一个接口中定义了 JDK 8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<p>除此之外，所有引用类型的方式都不会触发初始化(不代表不会触发加载操作)，称为被动引用，如</p>
<ol>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化；</li>
<li>通过数组定义类引用，不会触发此类的初始化；</li>
<li>引用常量不会触发此类的初始化，对于加载行为也不会触发（常量在链接阶段就存入调用类的常量池中了）</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.7">类的卸载</a>(java 语言规范 12.7)也需要满足一些条件：<a target="_blank" rel="noopener" href="https://gitee.com/yebukong/scratchpad/blob/main/scratchpad-simple/src/test/java/pers/mine/scratchpad/base/classload/ClassLoadUnloadTest.java">code</a></p>
<ul>
<li>该类所有的实例已经被回收</li>
<li>加载该类的 ClassLoder 已经被回收</li>
<li>该类对应的 java.lang.Class 对象没有任何对方被引用</li>
</ul>
<p>因此，由 java 虚拟机自带的三种类加载加载的类在虚拟机的整个生命周期中是不会被卸载的，因为引用始终存在，由用户自定义的类加载器所加载的类才可以被卸载。本质上类的卸载就是对方法区进行 gc 的过程。HotSpot 虚拟机提供了-Xnoclassgc 参数进行控制是否回收。</p>
<h2 id="类加载各个阶段"><a href="#类加载各个阶段" class="headerlink" title="类加载各个阶段"></a>类加载各个阶段</h2><p>概述:<br><img src="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655052017249-0d444c59-261c-4941-938f-c5998d287e62.png#clientId=u362b54ee-beaa-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6205efc4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=575&originWidth=896&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=230941&status=done&style=none&taskId=u3f144666-a062-41a0-9ec0-27310bcf95b&title=" alt="image.png"><br><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.2">java 语言规范 12.2</a></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，Java 虚拟机需要完成以下三件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。<br>这里并没有指明“二进制字节流”要从一个’.class’文件中获取，准确地说是根本没有指明要从哪里获取、怎样获取。<br>通常可以通过如下方式获取类的二进制字节流：<br>[1] 从本地系统中直接加载<br>[2] 从网络中获取，这种场景最典型的应用就是 Applet。<br>[3] 从 zip，jar 等归档文件中加载’.class’文件<br>[4] 从专有数据库中读取。<br>[5] 运行时计算生成，这种场景使用得最多的就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。<br>[6] 其他，。。。。。。<br>② 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。（在 JDK 8 中 Class 对象会被放在“元空间”）<br>③ 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li>
<li>将这个字节流所代表的静态存储结构转化为<strong>方法区</strong>的运行时数据结构。</li>
<li>在<strong>内存</strong>中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口，数组类是由 jvm 动态生成的。</li>
</ol>
<p><strong>可能抛出的异常：</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655697762109-a3c2a687-cbad-45a5-a817-500410d4f032.png#clientId=u762f29bb-63f0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=198&id=ucce46fe8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=198&originWidth=717&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=130243&status=done&style=none&taskId=u28ce919c-ba6f-43e9-a088-cb4998cf497&title=&width=717" alt="image.png"></p>
<blockquote>
<p>相对于类加载过程的其他阶段，非数组类型的加载阶段（准确地说，是加载阶段中获取类的二进 制字节流的动作）是开发人员可控性最强的阶段。加载阶段既可以使用 Java 虚拟机里内置的引导类加 载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节 流的获取方式（重写一个类加载器的 findClass()或 loadClass()方法），实现根据自己的想法来赋予应用 程序获取运行代码的动态性。<br>对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由 Java 虚拟机在运行时直接创建的（‘数组’的父类是’Object’）。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终是要靠类加载器去创建。</p>
</blockquote>
<blockquote>
<p>加载阶段结束后，Java 虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中 了，方法区中的数据存储格式完全由虚拟机实现自行定义。类型数据妥善安置在方法区之后，会在<strong>Java 堆内存</strong>中实例化一个 java.lang.Class 类的对象， 这个对象将作为程序<strong>访问方法区中的类型数据的外部接口</strong>。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/50258991">https://www.zhihu.com/question/50258991</a><br><img src="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655660461531-8d36e672-3d46-429a-80d6-5bd38f6e2ec7.png#clientId=u6fc6605e-52e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u962aedcd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=441&originWidth=728&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=44200&status=done&style=none&taskId=u60580985-df5e-4a3f-bcdd-e570e068f38&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655727911712-563b1b2e-fec6-4613-8183-0726d364bf81.png#clientId=ub570b698-5357-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=535&id=u473e7f78&margin=%5Bobject%20Object%5D&name=image.png&originHeight=535&originWidth=872&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=74738&status=done&style=none&taskId=ub95ffd72-51c1-49ed-9bcc-9c508531087&title=&width=872" alt="image.png"></p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚 拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全 。验证过程可能会导致某些额外的类和接口被加载进来 ，但不会导致它们也需要验证或准备 。此阶段的验证过程可能包含在其他阶段 ，验证大致分为 4 个方面：</p>
<ol>
<li>文件格式验证<br>第一阶段要验证字节流是否符合 Class 文件格式的规范(如魔数校验，版本号校验，字符串编码校验等)，并且能被当前版本的虚拟机处理 。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的 验证之后，这段字节流才被允许进入 Java 虚拟机内存的方法区中进行存储，所以后面的三个验证阶段 全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了 。</li>
<li>元数据验证<br>此阶段对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java 语言规范》的要求，如类是否存在父类、父类是否可以继承等</li>
<li>字节码验证<br>此阶段主要目的是通过数据流分析和控制流分析，确定 程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体（Class 文件中的 Code 属性）进行校验分析，保证被校验类的方法在运行时不会做出危害 虚拟机安全的行为 。</li>
<li>符号引用验证<br>此阶段校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者存在被禁止访问它依赖的某些外部类、方法、字段等资源。符号引用</li>
</ol>
<p>验证的目的是确保解析动作能正常执行，可能抛出的异常<br><img src="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655697820047-c699a92c-86f4-4e52-bf0e-122fbd46321e.png#clientId=u762f29bb-63f0-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u51c7fcce&margin=%5Bobject%20Object%5D&name=image.png&originHeight=133&originWidth=693&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=90623&status=done&style=none&taskId=u8c5f6b7e-bd98-49ca-9762-ae386a79de5&title=" alt="image.png"></p>
<blockquote>
<p>对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要（因为对程序运行期没有影响）的阶段。如果所运行的全部代码（包括自己编写的及第三方包中的代码）都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify：none 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
</blockquote>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类中定义的变量（即静态变量，被 static 修饰的变量）分配内存并设置类变量初始值的阶段，注意这里的初始值是 JVM 默认初始值，是固定的，不是代码中定义时的那个初始值，不过如果是常量值，jvm 会直接置为指定值。 这个阶段不会执行任何的虚拟机字节码指令。<a target="_blank" rel="noopener" href="https://gitee.com/yebukong/scratchpad/blob/main/scratchpad-simple/src/test/java/pers/mine/scratchpad/base/classload/ClassLoaderPrepareTest.java">code </a><br><img src="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655050522139-6f5d0a82-cbdb-4228-858d-1da356589d89.png#clientId=u362b54ee-beaa-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua57ef7a0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=338&originWidth=1116&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=72933&status=done&style=none&taskId=ud3dd855a-bbe1-4ce1-a89e-d4f5c4147f0&title=" alt="image.png"></p>
<h3 id="解析-可选"><a href="#解析-可选" class="headerlink" title="解析(可选)"></a>解析(可选)</h3><p>解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程，即是根据运行时常量池的符号引用来动态决定具体的值的过程。</p>
<blockquote>
<ul>
<li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同， 但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java 虚拟机规范》的 Class 文件格式中。</li>
<li>直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li>
</ul>
</blockquote>
<ul>
<li>静态解析</li>
<li>符号引用就是假如类 A 引用了类 B，加载阶段是静态解析，这时候 B 还没有被放到 JVM 内存中，这时候 A 引用的只是代表 B 的符号，这是符号引用。</li>
<li>直接引用就是类 A 在解析阶段发现自己引用了 B，如果这个时候 B 还没被加载。就是直接触发 B 的类加载，之后 B 的符号引用会被替换成实际地址。这被称为直接引用。</li>
<li>动态解析<br>如果代码使用了多态。B 是一个抽象类或者接口，A 就不能知道究竟要用哪个来替换，只能等到实际发生调动时在进行实际地址的替换。这就是为什么有的解析发生在初始化之后。<blockquote>
<p>《Java 虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行 anewarray 、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、 invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield 和 putstatic 这 17 个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来自行判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。<br>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这 7 类符号引用进行，分别对应于常量池的 CONSTANT_Class_info、CONSTANT_Fieldref_info、 CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、 CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dynamic_info 和 CONSTANT_InvokeDynamic_info 8 种常量类型。</p>
<ol>
<li>类或接口的解析<br>假设当前代码所处的类为 D，如果要把一个从未解析过的符号引用 N 解析为一个类或接口 C 的直接引用，那虚拟机完成整个解析的过程需要包括以下 3 个步骤：</li>
</ol>
<p>如果 C 不是一个数组类型，那虚拟机将会把代表 N 的全限定名传递给 D 的类加载器去加载这个 类 C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。<br>如果 C 是一个数组类型，并且数组的元素类型为对象，也就是 N 的描述符会是类<br>似“ [Ljava&#x2F;lang&#x2F;Integer”的形式，那将会按照第一点的规则加载数组元素类型。如果 N 的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表该数组维度和元素的数组对象。<br>如果上面两步没有出现任何异常，那么 C 在虚拟机中实际上已经成为一个有效的类或接口了， 但在解析完成前还要进行符号引用验证，确认 D 是否具备对 C 的访问权限。如果发现不具备访问权限，将抛出 java.lang.IllegalAccessError 异常。 2. 字段解析<br>要解析一个未被解析过的字段符号引用，首先将会对字段表内 class_index 项中索引的 CONSTANT_Class_info 符号引用进行解析，也就是字段所属的类或接口的符号引用。如果解析成功完成，那把这个字段所属的类或接口用 C 表示，《Java 虚拟机规范》要求按照如下步骤对 C 进行后续字段的搜索：</p>
<p>如果 C 本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。<br>否则，如果在 C 中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口， 如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。<br>否则，如果 C 不是 java.lang.Object 的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。<br>否则，查找失败，抛出 java.lang.NoSuchFieldError 异常。<br>如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出 java.lang.IllegalAccessError 异常。 3. 方法解析<br>方法解析的第一个步骤与字段解析一样，也是需要先解析出方法表的 class_index 项中索引的方法所属的类或接口的符号引用，如果解析成功，那么我们依然用 C 表示这个类，接下来虚拟机将会按照如下步骤进行后续的方法搜索：</p>
<p>由于 Class 文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的 方法表中发现 class_index 中索引的 C 是个接口的话，那就直接抛出 java.lang.Incomp atibleClassChangeError 异常。<br>如果通过了第一步，在类 C 中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则 返回这个方法的直接引用，查找结束。<br>否则，在类 C 的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。<br>否则，在类 C 实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类 C 是一个抽象类，这时候查找结束，抛出 java.lang.AbstractMethodError 异常。<br>否则，宣告方法查找失败，抛出 java.lang.NoSuchMethodError。<br>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出 java.lang.IllegalAccessError 异常。 4. 接口方法解析<br>接口方法也是需要先解析出接口方法表的 class_index 项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用 C 表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索:</p>
<p>与类的方法解析相反，如果在接口方法表中发现 class_index 中的索引 C 是个类而不是接口，那 么就直接抛出 java.lang.IncompatibleClassChangeError 异常。<br>否则，在接口 C 中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。<br>否则，在接口 C 的父接口中递归查找，直到 java.lang.Object 类（接口方法的查找范围也会包括 Object 类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。<br>否则，宣告方法查找失败，抛出 java.lang.NoSuchMethodError 异常。</p>
</blockquote>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655705401386-c50d50aa-7902-45fe-a41f-730808ad2df8.png#clientId=u7a32fd17-810c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=111&id=u5b76e185&margin=%5Bobject%20Object%5D&name=image.png&originHeight=111&originWidth=675&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=108370&status=done&style=none&taskId=u978d45f0-6fb5-4672-ad05-70755df63e1&title=&width=675" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655705386619-0011e56d-5159-4fb1-bfc8-70c7be3244eb.png#clientId=u7a32fd17-810c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=467&id=u55bb0ad3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=467&originWidth=663&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=357428&status=done&style=none&taskId=u5ca470c5-5b53-4beb-934f-c8ffde9310d&title=&width=663" alt="image.png"></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.4.2">初始化阶段</a>是类加载过程的最后一个步骤，之前介绍的几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由 Java 虚拟机来主导控 制。直到初始化阶段，Java 虚拟机才真正开始执行类中编写的 Java 程序代码，将主导权移交给应用程 序。同一个类加载器下，一个类型只会被初始化一次，初始化（Initialization）对于类或接口来说，就是执行它的初始化方法（_<clinit>_ ）。<br>关于<clinit> ：</p>
<ul>
<li><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的。</li>
<li><clinit>()方法与类的构造函数不同，它不需要显式地调用父类构造器，Java 虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。因此在 Java 虚拟机中第一个被执行的<clinit>()方法的类型肯定是 java.lang.Object。</li>
<li><clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。</li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。</li>
<li>Java 虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行完毕<clinit>()方法。如果在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个线程阻塞，不过在某个线程执行完<clinit>()后，其他线程都不会再执行<clinit>()方法。</li>
</ul>
<p>可能抛出的异常： NoClassDefFoundError，ExceptionInInitializerError ，OutOfMemoryError<br>关于 java 代码块的执行顺序(同一类加载器命名空间下首次加载)：<a target="_blank" rel="noopener" href="https://gitee.com/yebukong/scratchpad/blob/main/scratchpad-simple/src/test/java/pers/mine/scratchpad/base/classload/ClassLoadInitOrderTest.java">code</a><br>父类静态代码块&gt;子类类静态代码块&gt;父类构造块&gt;父类构造方法&gt;子类构造块&gt;子类构造方法</p>
<h2 id="类加载器与双亲委派机制"><a href="#类加载器与双亲委派机制" class="headerlink" title="类加载器与双亲委派机制"></a>类加载器与双亲委派机制</h2><h3 id="类加载器与类"><a href="#类加载器与类" class="headerlink" title="类加载器与类"></a>类加载器与类</h3><p>Java 类加载器是用户程序和 JVM 虚拟机之间的桥梁， 用于实现类的加载动作。<strong>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在 Java 虚拟机中的唯一性</strong>，每 一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相 等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个 Java 虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 这里所指的“相等”，包括代表类的 Class 对象的 equals()方法、isAssignableFrom()方法、isInstance() 方法的返回结果，也包括了使用 instanceof 关键字做对象所属关系判定等各种情况。<br>在 jvm 角度来看，只存在两种不同的类加载器：一种是启动类加载器（BootstrapClassLoader），这个类加载器使用 C++语言实现，是虚拟机自身的一部分；另外一种就是其他所有的类加载器，这些类加载器由 Java 语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。站在 Java 开发人员的角度来看，Java 则有着三层类加载器、双亲委派的类加载架构。</p>
<blockquote>
<p>命名空间<br>每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类组成。<br>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类<br>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类<br>可见性:<br>a）同一个命名空间内的类是相互可见的。<br>b）子加载器的命名空间包含所有父加载器的命名空间,因此由子加载器加载的类能看见父加载器加载的类。例如，系统类加载器加载的类能 看见根类加载器加载的类。<br>c）由父加载器加载的类不能看见子加载器加载的类。<br>如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载的类相互不可见。</p>
</blockquote>
<p>由类加载器不同及是否是数组类型引出的 jvm 三种类生成方式：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655057069184-da6095ba-9623-4b23-89e2-e7c637512113.png#clientId=u362b54ee-beaa-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9a565e09&margin=%5Bobject%20Object%5D&name=image.png&originHeight=271&originWidth=676&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=41413&status=done&style=none&taskId=u5384eac8-5482-4a23-86cb-8a73d41fe27&title=" alt="image.png"></p>
<h3 id="三层类加载器与双亲委派"><a href="#三层类加载器与双亲委派" class="headerlink" title="三层类加载器与双亲委派"></a>三层类加载器与双亲委派</h3><p>java9 之前的类加载器与双亲委派依赖<br><img src="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655057514597-ee3de33a-6706-4d16-ab6d-018a1a669235.png#clientId=u362b54ee-beaa-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=544&id=ubdd1ec86&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1087&originWidth=1336&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=345267&status=done&style=none&taskId=u6e15724a-8545-4337-9f08-e6fb91450f2&title=&width=668" alt="image.png"></p>
<ul>
<li>Bootstrap ClassLoader&#x2F;启动类加载器<br>c++实现，位于 jvm 内部，主要负责 jdk_home&#x2F;lib 目录下的核心 api 或 -Xbootclasspath 选项指定的 jar 包装入工做，如果某个类 xxxClass.getClassLoader()&#x3D;&#x3D;null，表示该类由启动类加载器加载，如果某个类加载器 xxxClassLoader.getParent()&#x3D;&#x3D;null,表示该类加载器的父加载器是启动类加载器。</li>
<li>Extension ClassLoader&#x2F;扩展类加载器<br>这个类加载器是在类 sun.misc.Launcher$ExtClassLoader 中以 Java 代码的形式实现的，主要负责 jdk_home&#x2F;lib&#x2F;ext 目录下的 jar 包或 -Djava.ext.dirs 指定目录下的 jar 包装入工做。</li>
<li>System ClassLoader&#x2F;应用类加载器<br>这个类加载器由 sun.misc.Launcher$AppClassLoader 来实现。 主要负责 java -classpath&#x2F;-Djava.class.path 所指的目录下的类与 jar 包装入工做。</li>
<li>User Custom ClassLoader&#x2F;用户自定义类加载器(java.lang.ClassLoader 的子类)<br>用户可以自定义实现类加载器，满足更灵活类加载需求。</li>
</ul>
<p>上图中类加载器之间的层次关系被称为类加载器的“双亲委派模型（Parents Delegation Model）”。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器，其中父加载器默认由 ClassLoader 类中的 parent 成员变量存储，可以通过构造方法设置。<br>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。<br>使用双亲委派模型来组织类加载器之间的关系，一个好处就是 Java 中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类 java.lang.Object，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都能够保证是同一个类。反之，如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中就会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)<span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 首先检查类是否已加载</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">////父加载器不为空，调用父加载器loadClass()方法处理</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//父加载器不为空，调用父加载器loadClass()方法处理</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// 抛出此异常表示父类加载器无法找到目标类</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 父类加载器无法加载，则自身加载</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="comment">// 实现自定义类加载器时，一般需要实现findClass方法</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他一些方法</span></span><br><span class="line"><span class="comment">//用于将 byte字节流解析成 JVM 能够识别的 Class 对象。有了这个方法意味着我们不仅可以通过 .class文件实例化对象，还可以通过其他方式实例化对象，例如通过网络接收到一个类的字节码。,一般在重写findClass方法时加载完字节码后再调用defineClass</span></span><br><span class="line">defineClass()</span><br><span class="line"></span><br><span class="line"><span class="comment">//通常和 defineClass()一起使用，我们需要直接覆盖 ClassLoader 父类的 findClass()方法来实现类的加载规则，从而取得要加载类的字节码。</span></span><br><span class="line">findClass()</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于对 Class 进行 链接，也就是把单一的 Class 加入到有继承关系的类树中。如果你想在类被加载到 JVM 中时就被链接（Link），那么可以在调用 defineClass()之后紧接着调用一个 resolveClass()方法，当然你也可以选择让 JVM 来解决什么时候才链接这个类（通常是真正被实实例化的时候)，默认不调用，代码验证，观察TODO</span></span><br><span class="line">resolveClass()</span><br><span class="line"></span><br><span class="line"><span class="comment">//类命名空间</span></span><br><span class="line"><span class="comment">// The classes loaded by this class loader. The only purpose of this table</span></span><br><span class="line"><span class="comment">// is to keep the classes from being GC&#x27;ed until the loader is GC&#x27;ed.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Vector&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// Invoked by the VM to record every loaded class with this loader.</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addClass</span><span class="params">(Class&lt;?&gt; c)</span> &#123;</span><br><span class="line">    classes.addElement(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">return</span> findLoadedClass0(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass0(String name);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)<span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>);</span><br><span class="line">                    <span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> ucp.getResource(path, <span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (res != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> defineClass(name, res);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, acc);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义类加载器的一些场景"><a href="#自定义类加载器的一些场景" class="headerlink" title="自定义类加载器的一些场景"></a><strong>自定义类加载器的一些场景</strong></h3><p><a target="_blank" rel="noopener" href="https://gitee.com/yebukong/scratchpad/blob/main/scratchpad-simple/src/test/java/pers/mine/scratchpad/base/classload/MyClassLoader.java">code</a></p>
<ul>
<li>隔离加载类。在某些框架内进行中间件与应用的模块隔离，把类加载器到不同的环境。比如，flink 的插件机制 jar 包不会影响到中间件运行时使用的 jar 包。</li>
<li>扩展加载源。比如从数据库、网络，甚至是电视机顶盒进行加载。</li>
<li>防止源码泄露。Java 代码容易被编译和篡改，可以进行编译加密。那么类加载器也需要自定义，还原加密的字节码。</li>
<li>热加载及类的卸载</li>
<li>…</li>
</ul>
<h3 id="破坏双亲委派机制的几种场景"><a href="#破坏双亲委派机制的几种场景" class="headerlink" title="破坏双亲委派机制的几种场景"></a>破坏双亲委派机制的几种场景</h3><blockquote>
<p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即 JDK 1.2 面世以前的“远古”时代。由于双亲委派模型在 JDK 1.2 之后才被引入，但是类加载器的概念和抽象类 java.lang.ClassLoader 则在 Java 的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java 设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免 loadClass()被子类覆盖的可能性，只能在 JDK 1.2 之后的 java.lang.ClassLoader 中添加一个新的 protected 方法 findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在 loadClass()中编写代码。上节我们已经分析过 loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照 loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的 findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的</p>
</blockquote>
<h4 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h4><p>此类加载器可以通过 java.lang.Thread 类的 setContextClassLoader()方 法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内 都没有设置过的话，那这个类加载器默认就是应用程序类加载器 AppClassLoader。 为了实现 SPI 等双亲委派无法实现的类加载场景引入。如 java.sql.DriverManager 用于实现驱动加载使用 java.util.ServiceLoader._load()。_java.sql.DriverManager.class 由启动类加载器加载 <a target="_blank" rel="noopener" href="https://gitee.com/yebukong/scratchpad/blob/main/scratchpad-simple/src/test/java/pers/mine/scratchpad/base/classload/ClassLoadErrorTest.java">code</a></p>
<h4 id="Tomcat-类加载器"><a href="#Tomcat-类加载器" class="headerlink" title="Tomcat 类加载器"></a>Tomcat 类加载器</h4><p>Tomcat 类加载器的设计，作为一个 web 容器可能需要部署多个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。如果使用默认加载器是无法完成加载两个相同类库的不同版本的，如果全限定类名相同则只会加载一份；作为 web 容器还需要支持 jsp 文件的热加载，如果我们改了 jsp 的内容，但是类名相同默认类加载器会直接查找方法区已经存在的，修改后的 jsp 是不会重新加载的。为了完成这个需求，Tomcat 通过一个新的 classloader 再次装载了该 jsp，每个 jsp 文件都对应一个唯一的类加载器。</p>
<h2 id="类加载的一些异常"><a href="#类加载的一些异常" class="headerlink" title="类加载的一些异常"></a>类加载的一些异常</h2><ul>
<li>类加载死锁<a target="_blank" rel="noopener" href="https://gitee.com/yebukong/scratchpad/blob/main/scratchpad-simple/src/test/java/pers/mine/scratchpad/base/classload/DeadLock.java">code</a></li>
<li>ClassNotFoundException 和 NoClassDefFoundError <a target="_blank" rel="noopener" href="https://gitee.com/yebukong/scratchpad/blob/main/scratchpad-simple/src/test/java/pers/mine/scratchpad/base/classload/ClassLoadErrorTest.java">code</a><br><img src="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655709127835-a02e73c4-9797-42b1-89ab-573f77080ecd.png#clientId=u299c494b-3abe-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=599&id=u2884fe05&margin=%5Bobject%20Object%5D&name=image.png&originHeight=599&originWidth=741&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=61084&status=done&style=none&taskId=u3cc4ab7e-09ef-48a2-aaf9-8bb40ba8df3&title=&width=741" alt="image.png"></li>
<li>java.lang.VerifyError: Bad return type (f248 flume 程序 hadoop 依赖异常)</li>
</ul>
<h2 id="模块化与类加载"><a href="#模块化与类加载" class="headerlink" title="模块化与类加载"></a>模块化与类加载</h2><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html#jvms-5.3.6">模块与层</a><br><img src="https://cdn.nlark.com/yuque/0/2022/png/28603640/1655711928599-1e3dd2d6-447a-446c-b7aa-04ae595efdd2.png#clientId=ue833c6b2-19ed-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=560&id=fqyky&margin=%5Bobject%20Object%5D&name=image.png&originHeight=560&originWidth=602&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=124033&status=done&style=none&taskId=u4523417f-4477-4238-af4a-d39ba84cffa&title=&width=602" alt="image.png"><br>JDK 9 为了模块化的支持，对双亲委派模式做了一些改动：</p>
<ol>
<li>扩展类加载器被平台类加载器（Platform ClassLoader）取代。<br>JDK 9 时基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数十个 JMOD 文件）， 其中的 Java 类库就已天然地满足了可扩展的需求，那自然无须再保留 <JAVA_HOME>\lib\ext 目录，此前使用这个目录或者 java.ext.dirs 系统变量来扩展 JDK 功能的机制已经没有继续存在的价值了</li>
<li>平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader。<br>现在启动类加载器、平台类加载器、应用程序类加载器全都继承 jdk.internal.loader.BuiltinClassLoader。</li>
<li>启动类加载器现在是在 Java 虚拟机内部和 Java 类库共同协作实现的类加载器（以前是 C++实现）。<br>为了与之前的代码保持兼容，所有在获取启动类加载器的场景（譬如 Object.class.getClassLoader）中仍然会返回 null 来代替，而不会得到 BootClassLoader 的实例。</li>
<li>类加载的委派关系也发生了变动。<br>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://gitee.com/yebukong/scratchpad/blob/main/scratchpad-java17/src/test/java/pers/mine/scratchpad/other/ClassLoaderTest.java">code</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BootClassLoader BOOT_LOADER;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> PlatformClassLoader PLATFORM_LOADER;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AppClassLoader APP_LOADER;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The class loader that is used to find resources in modules defined to</span></span><br><span class="line"><span class="comment"> * the boot class loader. It is not used for class loading.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BootClassLoader</span> <span class="keyword">extends</span> <span class="title class_">BuiltinClassLoader</span> &#123;</span><br><span class="line">    BootClassLoader(URLClassPath bcp) &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="literal">null</span>, <span class="literal">null</span>, bcp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClassOrNull(String cn, <span class="type">boolean</span> resolve) &#123;</span><br><span class="line">        <span class="keyword">return</span> JLA.findBootstrapClassOrNull(cn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The platform class loader, a unique type to make it easier to distinguish</span></span><br><span class="line"><span class="comment"> * from the application class loader.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PlatformClassLoader</span> <span class="keyword">extends</span> <span class="title class_">BuiltinClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ClassLoader.registerAsParallelCapable())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PlatformClassLoader(BootClassLoader parent) &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;platform&quot;</span>, parent, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The application class loader that is a &#123;<span class="doctag">@code</span> BuiltinClassLoader&#125; with</span></span><br><span class="line"><span class="comment"> * customizations to be compatible with long standing behavior.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AppClassLoader</span> <span class="keyword">extends</span> <span class="title class_">BuiltinClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ClassLoader.registerAsParallelCapable())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AppClassLoader(BuiltinClassLoader parent, URLClassPath ucp) &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;app&quot;</span>, parent, ucp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String cn, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// for compatibility reasons, say where restricted package list has</span></span><br><span class="line">        <span class="comment">// been updated to list API packages in the unnamed module.</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;removal&quot;)</span></span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cn.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (i != -<span class="number">1</span>) &#123;</span><br><span class="line">                sm.checkPackageAccess(cn.substring(<span class="number">0</span>, i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(cn, resolve);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> PermissionCollection <span class="title function_">getPermissions</span><span class="params">(CodeSource cs)</span> &#123;</span><br><span class="line">        <span class="type">PermissionCollection</span> <span class="variable">perms</span> <span class="operator">=</span> <span class="built_in">super</span>.getPermissions(cs);</span><br><span class="line">        perms.add(<span class="keyword">new</span> <span class="title class_">RuntimePermission</span>(<span class="string">&quot;exitVM&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> perms;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called by the VM to support dynamic additions to the class path</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.instrument.Instrumentation#appendToSystemClassLoaderSearch</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">appendToClassPathForInstrumentation</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        appendClassPath(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called by the VM to support define package for AppCDS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Package <span class="title function_">defineOrCheckPackage</span><span class="params">(String pn, Manifest man, URL url)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.defineOrCheckPackage(pn, man, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called by the VM, during -Xshare:dump</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resetArchivedStates</span><span class="params">()</span> &#123;</span><br><span class="line">        setClassPath(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClassOrNull(String cn, <span class="type">boolean</span> resolve) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(cn)) &#123;</span><br><span class="line">        <span class="comment">// check if already loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(cn);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// find the candidate module for this class</span></span><br><span class="line">            <span class="comment">//模块是否加载过</span></span><br><span class="line">            <span class="type">LoadedModule</span> <span class="variable">loadedModule</span> <span class="operator">=</span> findLoadedModule(cn);</span><br><span class="line">            <span class="keyword">if</span> (loadedModule != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// package is in a module</span></span><br><span class="line">                <span class="comment">//使用模块加载器加载</span></span><br><span class="line">                <span class="type">BuiltinClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> loadedModule.loader();</span><br><span class="line">                <span class="keyword">if</span> (loader == <span class="built_in">this</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果模块加载器是自己，就直接加载</span></span><br><span class="line">                    <span class="keyword">if</span> (VM.isModuleSystemInited()) &#123;</span><br><span class="line">                        c = findClassInModuleOrNull(loadedModule, cn);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// delegate to the other loader</span></span><br><span class="line">                    c = loader.loadClassOrNull(cn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// check parent</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClassOrNull(cn);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// check class path</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span> &amp;&amp; hasClassPath() &amp;&amp; VM.isModuleSystemInited()) &#123;</span><br><span class="line">                    c = findClassOnClassPathOrNull(cn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve &amp;&amp; c != <span class="literal">null</span>)</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从-jvm-源码看-main-方法调用过程"><a href="#从-jvm-源码看-main-方法调用过程" class="headerlink" title="从 jvm 源码看 main 方法调用过程"></a>从 jvm 源码看 main 方法调用过程</h2><p>_JAVA_LAUNCHER_DEBUG&#x3D;1<br>&#x2F;&#x2F;从 openjdk8 源码开始， java9 之后 checkAndLoadMain 方法还在<br>&#x2F;&#x2F;sun.launcher.LauncherHelper#checkAndLoadMain<br>&#x2F;&#x2F;ClassLoader.getSystemClassLoader() -&gt; initSystemClassLoader() -&gt; sun.misc.Launcher.getLauncher()</p>
<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">💡[ java程序退出的条件，满足其一  (java语言规范 12.8):](https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.8)
    - 所有非守护线程的线程退出。
    - 某个线程中直接调用Runtime或类System的exit,（halt）方法，且安全管理器没有禁止退出操作。</div>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se8/html/index.html">java8 语言规范</a><br><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">java8 虚拟机规范</a><br><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">java 参数</a><br><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html#jvms-5.3">java9 虚拟机规范</a></p>
<p><a target="_blank" rel="noopener" href="https://gorden5566.com/post/1060.html">https://gorden5566.com/post/1060.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/huangzhilin2015/article/details/114873607">https://blog.csdn.net/huangzhilin2015/article/details/114873607</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8e8a5a773648">https://www.jianshu.com/p/8e8a5a773648</a><br><a target="_blank" rel="noopener" href="https://www.codeboy.me/2020/07/25/java-class-not-def-found-error/">https://www.codeboy.me/2020/07/25/java-class-not-def-found-error/</a><br><a target="_blank" rel="noopener" href="https://heapdump.cn/article/281539">https://heapdump.cn/article/281539</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021292121">https://segmentfault.com/a/1190000021292121</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/97650770">https://zhuanlan.zhihu.com/p/97650770</a><br><a target="_blank" rel="noopener" href="https://www.modb.pro/db/250061">https://www.modb.pro/db/250061</a><br><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/518315">https://developer.aliyun.com/article/518315</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/215684718">https://zhuanlan.zhihu.com/p/215684718</a><br><a target="_blank" rel="noopener" href="https://linling1.github.io/programming_blog/2019/11/09/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2-JVM-%E6%96%87%E9%9B%86/">https://linling1.github.io/programming_blog&#x2F;2019&#x2F;11&#x2F;09&#x2F;%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2-JVM-%E6%96%87%E9%9B%86&#x2F;</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/06/yuque/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/" data-id="cl77zxsjt0001d5or7ifx4nk0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/08/25/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/25/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2022/06/06/yuque/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/">Java类加载</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 叶不空<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>